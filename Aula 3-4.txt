[Precisamos agora de um local para armazenar essa lista de colaboradores, precisamos passar isso adiante.
Ou seja, alguém precisa ouvir esse evento de cadastrar colaborador e guardar isso em algum outro estado
que não seja o do formulário.

Como falado, a responsabilidade do formulário não é armazenar a lista de colaboradores, mas conter os seus campos.]


A gente precisa mexer no App.js e, lá na parte do <Formulario />, fazer ele ouvir um evento / função, no qual terá
acesso a um "colaborador" e precisaremos fazer algo com ele.

<Formulario aoColaboradorCadastrado={colaborador => ???}/>

Vamos criar uma constante que recebe o valor e o estado do colaborador iguais ao useState. Desta vez o useState
será um array vazio, sem aspas.

const [colaboradores, setColaboradores] = useState([])
(lembrando que é preciso importar o useState para que funcione corretamente)


[Cada vez que esse colaborador for cadastrado, queremos pegar e concatenar ele ao que já existia. Pegar o que já
tinha e colocar um novo.
Melhor, vamos criar uma função que aparecerá no <Formulario> para extrair console.logs e entender o que está acontecendo.]



const aoNovoColaboradorAdicionado = (colaborador) => {
    console.log(colaborador)
}

<Formulario aoColaboradorCadastrado={aoNovoColaboradorAdicionado(colaborador)}/>


Agora, no index do Formulario, faça com que a const "Formulario" receba o parâmetro "props" e a função aoSalvar tenha um
props.aoColaboradorCadastrado({as quatro labels do formulario}).


[OBS: Por alguma razão ele não retorna o time se você não mudar de opção, mesmo que esteja com a opção padrão.]


Voltando ao App.js, o que eu tenho que fazer é ir na função aoNovoColaboradorAdicionado pedir para que o
setColaboradores receba um array cujo primeiro índice são todos os colaboradores anteriores e o segundo
índice, o novo valor, será o colaborador novo.



[No Figma nós temos uma lista de times e nossa aplicação ainda não está no lugar certo. A aplicação está
na pasta "Formulario". Percebam, nós temos o Formulario que precisa de uma lista de times e uma App.js
que também precisa de uma lista de times. Podemos até fazer um copypaste e ter a lista de time em dois lugares,
mas não seria uma boa estratégia porque sempre teríamos dois lugares para mexer. Ou seja, precisamos
receber esse *time* via *prop* lá no "App.js". Além disso, o time precisa ter as cores de fundo e de destaque!]




----Bônus----

Qual a diferença entre controlar uma variável com o useState e criar e atribuir normalmente uma let?

R: Sempre que queremos que o componente reaja a alguma alteração no valor de uma variável e se renderize novamente,
precisamos indicar isto utilizando o useState. Do contrário, o valor vai ser alterado mas o DOM não será atualizado.




[React tem duas abordagens diferentes para lidar com inputs de formulários.

Um elemento de input de formulário cujo valor é controlado pelo React é chamado de componente controlado
(statefull em inglês). Quando o usuário insere dados em um componente controlado, o evento que manipula
essa alteração é disparado e o seu código decide se o input é válido (ou seja, renderizado com o valor
atualizado). Se você não re-renderizar o elemento de formulário, permanecerá inalterado.

Um componente não controlado (stateless em inglês) funciona como um elemento de formulário fora do React.
Quando um usuário insere dados em um campo de formulário (um input box, dropbox, etc), a informação atualizada
é refletida sem necessidade do React fazer nada. No entanto, isso também significa que você não pode forçar
o campo a ter um certo valor.]